<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
	<script async src="https://mcbeeringi.github.io/src/gas.js"></script>

	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>McbeEringi glyph_gen</title>
	<meta name="description" content="mc glyph generator">
	<link rel="icon" type="image/svg+xml" href="../../img/icon.svg">
	<link rel="apple-touch-icon" href="../../img/icon.png">
	<meta name="theme-color" content="#214"/>

	<link rel="stylesheet" href="../../src/style.css">
</head>
<body>
<style>
	:root{tab-size:2;}
	#ta{width:100%;font-family:monospace;}
	#c{width:min(720px,100%);background:0 0/12.5% url("data:image/svg+xml,%3Csvg viewBox='0 0 2 2' xmlns='http://www.w3.org/2000/svg'%3E%3Cpolygon points='0,0 1,0 1,2 2,2 2,1 0,1' fill='%238884'/%3E%3C/svg%3E");}
</style>
<h1>glyph_gen</h1>
<hr>
<label>font-file: <input type="file" id="file" class="zab" accept=".ttf,.ttc,.otf,.otc,.woff,.woff2"></label>
<pre id="flog"></pre>
<textarea id="ta" class="zab" spellcheck="false">// configs
{
	name:'font resource pack',
	img:64,
	font:'56px sans-serif',// "your-loaded-font-file.ttf"
	list:[...Array(256).keys()].filter(i=>i<0xd8||0xf5<i),

	threads:4,// If less than or equal to 0, the main thread is used.(higher browser compatibility)
	preview:0x00
}</textarea>
<button id="btn" class="zab bgca">export</button>
<div id="elog"></div>
<canvas id="c"></canvas>


<script type="module">
import TA from 'https://mcbeeringi.github.io/ta/ta.mjs';
import {zip,dl} from 'https://mcbeeringi.github.io/petit/zip.mjs';
const
ctx=c.getContext('2d'),
cfgget=_=>{try{return Function(`return(${ta.value});`)()}catch(e){}},
cfgset=(ctx,_)=>(ctx.canvas.width=ctx.canvas.height=_.img*16,ctx.fillStyle='#fff',ctx.textBaseline='middle',ctx.font=_.font),
draw=(ctx,p)=>(ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height),[...Array(255)].forEach((x=ctx.canvas.width/16,i)=>ctx.fillText(String.fromCharCode(p<<8|i),(i%16)*x,((i/16|0)+.5)*x,x))),
i2p=i=>`font/${i.toString(16).padStart(2,0)}.png`,
flist=[],
fload=async(x,w=document,_)=>(w.fonts.add(await new FontFace(`"${x.name}"`,`url(${_=URL.createObjectURL(x)})`).load()),URL.revokeObjectURL(_)),
main=async w=>(w=cfgget())&&(
	w={cfg:w,log:document.createElement('pre')},
	w.log.textContent='running...',
	elog.append(w.log),
	w.blob=OffscreenCanvas&&0<w.cfg.threads?await new Promise((f,r,q=[])=>[...Array(w.cfg.threads)].forEach(async(x,i,a)=>(
		x=new Worker('data:application/javascript,onmessage=m=>Object.getPrototypeOf(async _=>_).constructor("w",m.data.main)(m.data);'),
		await new Promise(f=>(
			x.onmessage=f,
			x.postMessage({flist,cfg:w.cfg,main:`
				self.draw=${draw};self.i2p=${i2p};self.fload=${fload};
				await Promise.all(w.flist.map(x=>fload(x,self)));
				(${cfgset})(self.ctx=new OffscreenCanvas(1,1).getContext('2d'),w.cfg);
				onmessage=m=>m.data.map(async x=>postMessage({path:i2p(x),blob:await ctx.canvas.convertToBlob(draw(ctx,x&0xff))}));
				postMessage(0);
			`})
		)),
		x.onmessage=m=>(q.push(m.data),w.log.textContent=`${q.length}/${w.cfg.list.length} ( ${m.data.path} )`,w.cfg.list.length<=q.length&&f(q)),
		a=Math.ceil(w.cfg.list.length/a.length),
		x.postMessage(w.cfg.list.slice(a*i,a*(i+1)))
	))):(
		cfgset(w.ctx=document.createElement('canvas').getContext('2d'),w.cfg),
		await Promise.all(w.cfg.list.map((x,i,a)=>new Promise(f=>setTimeout(async _=>(
			draw(w.ctx,x=x&0xff),
			x={path:i2p(x),blob:await new Promise(f=>w.ctx.canvas.toBlob(f))},
			w.log.textContent=`${i+1}/${a.length} ( ${x.path} )`,
			f(x)
		)))))
	),
	dl({name:w.cfg.name+'.zip',blob:await zip(w.blob,w.log.textContent='packing...')}),
	w.log.remove()
);

TA.editor(ta);
ta.oninput=_=>(_=cfgget())&&(
	cfgset(ctx,_),
	draw(ctx,_.preview&0xff)
);
(file.onchange=async _=>(
	file.files[0]&&(flist.push(file.files[0]),await fload(file.files[0]),flog.textContent=JSON.stringify({loaded_fonts:flist.map(x=>x.name)},0,'	')),
	ta.oninput()
))();
btn.onclick=_=>main();
</script>
</body>
<html>
